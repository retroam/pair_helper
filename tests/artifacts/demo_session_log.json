{
  "question_name": "ruleengine",
  "mode_switches": [
    {
      "timestamp": 1770538948.502274,
      "previous": "bot_drives",
      "current": "human_drives",
      "trigger": "demo"
    }
  ],
  "struggle_moments": [
    {
      "timestamp": 11.0,
      "kind": "backtrack",
      "context": {
        "previous_size": 5,
        "current_size": 1
      }
    }
  ],
  "browserbase_lookups": [
    {
      "query": "snapshot restore pattern in python",
      "summary": "Snapshot/restore usually stores a deep copy of mutable state at a timestamp and restores that copy later."
    }
  ],
  "test_timeline": [],
  "final_code": "\"\"\"Rule Engine starter.\n\nImplement a rule engine that evaluates conditions against data records\nand fires matching actions.\n\nLevels:\n- Level 1: simple conditions (field op value), add/evaluate/remove rules.\n- Level 2: compound conditions (AND/OR groups), nested evaluation.\n- Level 3: priority ordering, group-based conflict resolution.\n- Level 4: timestamped evaluation history, snapshots, restore.\n\nAll query responses are strings.\n\"\"\"\n\nfrom copy import deepcopy\nimport json\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\n\n\n@dataclass\nclass Rule:\n    name: str\n    condition: dict\n    action: str\n    priority: int = 0\n    group: str = \"\"\n\n\nclass RuleEngine:\n    def __init__(self):\n        self._rules: Dict[str, Rule] = {}\n        self._history: Dict[str, List[str]] = {}\n        self._fire_counts: Dict[str, int] = {}\n        self._snapshots: Dict[str, Dict[str, Rule]] = {}\n\n    @staticmethod\n    def _parse_int(value: str, default: Optional[int] = 0) -> Optional[int]:\n        try:\n            return int(value)\n        except (TypeError, ValueError):\n            return default\n\n    @staticmethod\n    def _parse_record(record_str: str) -> Dict[str, str]:\n        record: Dict[str, str] = {}\n        if not record_str:\n            return record\n        for pair in record_str.split(\",\"):\n            pair = pair.strip()\n            if not pair or \"=\" not in pair:\n                continue\n            key, value = pair.split(\"=\", 1)\n            record[key.strip()] = value.strip()\n        return record\n\n    @staticmethod\n    def _simple_match(record: Dict[str, str], field: str, operator: str, value: str) -> bool:\n        if field not in record:\n            return False\n        field_value = record[field]\n        if operator == \"eq\":\n            return field_value == value\n        if operator == \"neq\":\n            return field_value != value\n\n        left = RuleEngine._parse_int(field_value, default=None)\n        right = RuleEngine._parse_int(value, default=None)\n        if left is None or right is None:\n            return False\n\n        if operator == \"gt\":\n            return left > right\n        if operator == \"lt\":\n            return left < right\n        if operator == \"gte\":\n            return left >= right\n        if operator == \"lte\":\n            return left <= right\n        return False\n\n    def _condition_matches(self, condition: dict, record: Dict[str, str]) -> bool:\n        if \"and\" in condition:\n            sub = condition.get(\"and\")\n            if not isinstance(sub, list):\n                return False\n            return all(self._condition_matches(item, record) for item in sub)\n        if \"or\" in condition:\n            sub = condition.get(\"or\")\n            if not isinstance(sub, list):\n                return False\n            return any(self._condition_matches(item, record) for item in sub)\n\n        field = condition.get(\"field\")\n        operator = condition.get(\"op\")\n        value = condition.get(\"value\")\n        if not isinstance(field, str) or not isinstance(operator, str) or not isinstance(value, str):\n            return False\n        return self._simple_match(record, field, operator, value)\n\n    @staticmethod\n    def _rule_sort_key(rule: Rule):\n        return (-rule.priority, rule.action, rule.name)\n\n    @staticmethod\n    def _group_sort_key(rule: Rule):\n        return (-rule.priority, rule.name)\n\n    def add_rule(self, name: str, field: str, operator: str, value: str,\n                 action: str, priority: str = \"0\", group: str = \"\") -> str:\n        \"\"\"Add a simple condition rule. Return 'true' or 'false' if name exists.\"\"\"\n        if name in self._rules:\n            return \"false\"\n        if operator not in {\"eq\", \"neq\", \"gt\", \"lt\", \"gte\", \"lte\"}:\n            return \"false\"\n        self._rules[name] = Rule(\n            name=name,\n            condition={\"field\": field, \"op\": operator, \"value\": value},\n            action=action,\n            priority=self._parse_int(priority, default=0),\n            group=group or \"\",\n        )\n        return \"true\"\n\n    def add_compound_rule(self, name: str, condition_json: str, action: str,\n                          priority: str = \"0\", group: str = \"\") -> str:\n        \"\"\"Add a compound condition rule (JSON). Return 'true' or 'false'.\"\"\"\n        if name in self._rules:\n            return \"false\"\n        try:\n            condition = json.loads(condition_json)\n        except json.JSONDecodeError:\n            return \"false\"\n        if not isinstance(condition, dict):\n            return \"false\"\n        self._rules[name] = Rule(\n            name=name,\n            condition=condition,\n            action=action,\n            priority=self._parse_int(priority, default=0),\n            group=group or \"\",\n        )\n        return \"true\"\n\n    def remove_rule(self, name: str) -> str:\n        \"\"\"Remove a rule by name. Return 'true' or 'false'.\"\"\"\n        if name not in self._rules:\n            return \"false\"\n        del self._rules[name]\n        return \"true\"\n\n    def evaluate(self, record_str: str, timestamp: str = \"\") -> str:\n        \"\"\"Evaluate record against all rules. Return comma-separated fired actions or ''.\"\"\"\n        record = self._parse_record(record_str)\n        matched_rules = [rule for rule in self._rules.values() if self._condition_matches(rule.condition, record)]\n\n        ungrouped: List[Rule] = []\n        grouped_matches: Dict[str, List[Rule]] = {}\n        for rule in matched_rules:\n            if rule.group:\n                grouped_matches.setdefault(rule.group, []).append(rule)\n            else:\n                ungrouped.append(rule)\n\n        fired: List[Rule] = list(ungrouped)\n        for rules in grouped_matches.values():\n            best = sorted(rules, key=self._rule_sort_key)[0]\n            fired.append(best)\n\n        fired = sorted(fired, key=self._rule_sort_key)\n\n        if timestamp:\n            ts = str(timestamp)\n            for rule in fired:\n                self._history.setdefault(rule.name, []).append(ts)\n                self._fire_counts[rule.name] = self._fire_counts.get(rule.name, 0) + 1\n\n        return \",\".join(rule.action for rule in fired)\n\n    def match_count(self, record_str: str) -> str:\n        \"\"\"Return the number of matching rules as a string.\"\"\"\n        record = self._parse_record(record_str)\n        count = 0\n        for rule in self._rules.values():\n            if self._condition_matches(rule.condition, record):\n                count += 1\n        return str(count)\n\n    def list_group(self, group_name: str) -> str:\n        \"\"\"Return comma-separated rule names in group sorted by priority desc, or ''.\"\"\"\n        rules = [rule for rule in self._rules.values() if rule.group == group_name]\n        if not rules:\n            return \"\"\n        rules = sorted(rules, key=self._group_sort_key)\n        return \",\".join(rule.name for rule in rules)\n\n    def history(self, rule_name: str) -> str:\n        \"\"\"Return comma-separated timestamps where rule fired, or ''.\"\"\"\n        return \",\".join(self._history.get(rule_name, []))\n\n    def top_rules(self, n: str) -> str:\n        \"\"\"Return top N most-fired rule names, sorted by count desc then alpha.\"\"\"\n        limit = self._parse_int(n, default=0)\n        if limit <= 0:\n            return \"\"\n        ranked = sorted(self._fire_counts.items(), key=lambda item: (-item[1], item[0]))\n        return \",\".join(name for name, _ in ranked[:limit])\n\n    def snapshot(self, timestamp: str) -> str:\n        \"\"\"Save current rule set at timestamp. Return number of rules as string.\"\"\"\n        self._snapshots[str(timestamp)] = deepcopy(self._rules)\n        return str(len(self._rules))\n\n    def restore(self, timestamp: str) -> str:\n        \"\"\"Restore rule set from snapshot. Return 'true' or 'false'.\"\"\"\n        key = str(timestamp)\n        if key not in self._snapshots:\n            return \"false\"\n        self._rules = deepcopy(self._snapshots[key])\n        return \"true\"\n"
}